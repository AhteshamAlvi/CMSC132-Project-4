package game;

import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;

public class Tank extends Polygon implements KeyListener{
	private int[] x,y;
	private double increment, originalRotation, obs;
	private int degrees, keyL, keyF, keyR, keyB, keyS;
	private boolean forwards, backwards, left, right;
	private ArrayList<Canon> canon, remove;
	private Canon projectile;
	
	public Tank(Point[] inShape, Point inPosition, double inRotation, 
			int keyL, int keyF, int keyR, int keyB, int keyS) {
		super(inShape, inPosition, inRotation);
		
		this.x = new int[this.getPoints().length];
		this.y = new int[this.getPoints().length];
		
		this.increment = 2;
		this.degrees = 2;
		this.obs = .05;
		this.originalRotation = inRotation;
		
		this.keyL = keyL;
		this.keyF = keyF;
		this.keyR = keyR; 
		this.keyB = keyB; 
		this.keyS = keyS;
		
		this.forwards = false;
		this.backwards = false;
		this.left = false;
		this.right = false;

		this.canon = new ArrayList<>(); 
		this.remove = new ArrayList<>();

	}
	
	public void paint(Graphics brush) {		
		
		for(int i = 0; i < this.getPoints().length; i++) {
			this.x[i] = (int) this.getPoints()[i].getX();
			this.y[i] = (int) this.getPoints()[i].getY();
		}

		for (int i = 0; i < canon.size(); i++) {
		    Canon projectile = canon.get(i);
		    projectile.paint(brush);
		} 
		
		brush.drawPolygon(this.x, this.y, 12);
	}
	
	public void move() {
		if(this.left && this.forwards 
				&& (this.tankObstacleCollision(RandomPolygons.getPolygons())
				|| obstacleTankCollision(this,RandomPolygons.getPolygons()))) {
			this.rotate(-this.degrees);
			super.position.setX(super.position.getX() 
					+ Math.cos(Math.toRadians(rotation)) * increment * obs);
			super.position.setY(super.position.getY() 
					+ Math.sin(Math.toRadians(rotation)) * increment * obs);
			
		} else if(this.right && this.forwards 
				&& (this.tankObstacleCollision(RandomPolygons.getPolygons())
				|| obstacleTankCollision(this,RandomPolygons.getPolygons()))) {
			this.rotate(this.degrees);
			super.position.setX(super.position.getX() 
					+ Math.cos(Math.toRadians(rotation)) * increment * obs);
			super.position.setY(super.position.getY()
					+ Math.sin(Math.toRadians(rotation)) * increment * obs);
		
		} else if(this.left && this.backwards 
				&& (this.tankObstacleCollision(RandomPolygons.getPolygons())
				|| obstacleTankCollision(this,RandomPolygons.getPolygons()))) {
			this.rotate(-this.degrees);
			super.position.setX(super.position.getX() 
					- Math.cos(Math.toRadians(rotation)) * increment * obs);
			super.position.setY(super.position.getY() 
					- Math.sin(Math.toRadians(rotation)) * increment * obs);

		} else if(this.right && this.backwards 
				&& (this.tankObstacleCollision(RandomPolygons.getPolygons())
				|| obstacleTankCollision(this,RandomPolygons.getPolygons()))) {
			this.rotate(this.degrees);
			super.position.setX(super.position.getX() 
					- Math.cos(Math.toRadians(rotation)) * increment * obs);
			super.position.setY(super.position.getY() 
					- Math.sin(Math.toRadians(rotation)) * increment * obs);
		
		} else if(this.forwards
				&& (this.tankObstacleCollision(RandomPolygons.getPolygons())
				|| obstacleTankCollision(this,RandomPolygons.getPolygons()))) {
			super.position.setX(super.position.getX() 
					+ Math.cos(Math.toRadians(rotation)) * increment * obs);
			super.position.setY(super.position.getY() 
					+ Math.sin(Math.toRadians(rotation)) * increment * obs);
			
		} else if(this.backwards
				&& (this.tankObstacleCollision(RandomPolygons.getPolygons())
				|| obstacleTankCollision(this,RandomPolygons.getPolygons()))) {
			super.position.setX(super.position.getX() 
					- Math.cos(Math.toRadians(rotation)) * increment * obs);
			super.position.setY(super.position.getY() 
					- Math.sin(Math.toRadians(rotation)) * increment * obs);
			
		} else if(this.left && this.forwards) {
			this.rotate(-this.degrees);
			super.position.setX(super.position.getX() 
					+ Math.cos(Math.toRadians(rotation)) * increment);
			super.position.setY(super.position.getY() 
					+ Math.sin(Math.toRadians(rotation)) * increment);
			
		} else if(this.right && this.forwards) {
			this.rotate(this.degrees);
			super.position.setX(super.position.getX() 
					+ Math.cos(Math.toRadians(rotation)) * increment);
			super.position.setY(super.position.getY() 
					+ Math.sin(Math.toRadians(rotation)) * increment);
			
		} else if(this.left && this.backwards) {
			this.rotate(-this.degrees);
			super.position.setX(super.position.getX() 
					- Math.cos(Math.toRadians(rotation)) * increment);
			super.position.setY(super.position.getY() 
					- Math.sin(Math.toRadians(rotation)) * increment);
			
		} else if(this.right && this.backwards) {
			this.rotate(this.degrees);
			super.position.setX(super.position.getX() 
					- Math.cos(Math.toRadians(rotation)) * increment);
			super.position.setY(super.position.getY() 
					- Math.sin(Math.toRadians(rotation)) * increment);
		
		} else if(this.left) {
			this.rotate(-this.degrees);
		
		} else if(this.right) {
			this.rotate(this.degrees);	
			
		} else if(this.forwards) {
			super.position.setX(super.position.getX() 
					+ Math.cos(Math.toRadians(rotation)) * increment);
			super.position.setY(super.position.getY() 
					+ Math.sin(Math.toRadians(rotation)) * increment);
			
		} else if(this.backwards) {
			super.position.setX(super.position.getX() 
					- Math.cos(Math.toRadians(rotation)) * increment);
			super.position.setY(super.position.getY() 
					- Math.sin(Math.toRadians(rotation)) * increment);
		}

		for (int i = 0; i < canon.size(); i++) {
		    this.projectile = canon.get(i);
		    this.projectile.move();
		    if (this.projectile.getPosition().getX() < 0 
		    		|| this.projectile.getPosition().getX() > 800 
		    		|| this.projectile.getPosition().getY() < 0 
		    		|| this.projectile.getPosition().getY() > 600) {
		    	
		        this.remove.add(projectile);
		    }
		}
		this.canon.removeAll(remove); 
	}
	
	private void shoot() {
	    Canon newProjectile = new Canon(new Point(super.position.getX(), 
	    		super.position.getY()), super.rotation, 5);
	    canon.add(newProjectile);
	} 
	
	public ArrayList<Canon> getCanon() {
		return this.canon;
	}
	
	public ArrayList<Canon> getRemove() {
		return this.remove;
	}
	
	public void death(double x, double y) {
		super.position.setX(x);
		super.position.setY(y);
		super.rotation = originalRotation;
	}
	
	public void victory(double x, double y) {
		super.position.setX(x);
		super.position.setY(y);
		super.rotation = originalRotation;
	}

	@Override
	public void keyPressed(KeyEvent e) {
		if(e.getKeyCode() == this.keyL) {
			this.left = true;
		} else if(e.getKeyCode() == this.keyF) {
			this.forwards = true;
		} else if(e.getKeyCode() == this.keyR) {
			this.right = true;
		} else if(e.getKeyCode() == this.keyB) {
			this.backwards = true;
		} else if (e.getKeyCode() == this.keyS) { 
			shoot();
		}
	}

	@Override
	public void keyReleased(KeyEvent e) {
		if(e.getKeyCode() == this.keyL) {
			this.left = false;
		} else if(e.getKeyCode() == this.keyF) {
			this.forwards = false;
		} else if(e.getKeyCode() == this.keyR) {
			this.right = false;
		} else if(e.getKeyCode() == this.keyB) {
			this.backwards = false;
		}
	}	
	
	@Override
	public void keyTyped(KeyEvent e) {}
}
